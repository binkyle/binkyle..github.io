import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as s,a,b as o,f as c}from"./app-f3fb8442.js";const p={},t=o("p",null,"本文主要介绍C语言中sizeof的原理分析",-1),i=c(`<h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理" aria-hidden="true">#</a> 原理</h2><p><code>sizeof</code> 是 C 语言的一个运算符，用于返回一个对象或数据类型的大小，以字节为单位。<code>sizeof</code> 运算符在编译时计算，不会执行实际的运算。</p><p>由于 <code>sizeof</code> 是编译时计算大小的，其实现是由编译器提供的，而不是由标准 C 库提供的函数。因此，<code>sizeof</code> 的实现通常依赖于编译器和目标体系结构。</p><h2 id="实现方式" tabindex="-1"><a class="header-anchor" href="#实现方式" aria-hidden="true">#</a> 实现方式</h2><p>以下是 <code>sizeof</code> 运算符的一种可能的简化实现，假设一个字节等于 8 比特：</p><p>test.c文件</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SIZEOF</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>type<span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token comment">// 示例用法</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">SIZEOF</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个宏的工作原理是，将一个空指针转换为类型 <code>type*</code>，然后取数组的第一个元素的地址。由于数组索引是从零开始的，<code>&amp;((type*)0)[1]</code> 计算出第一个元素之后的地址。然后，整个表达式被强制转换为 <code>size_t</code> 类型，以表示大小。</p><p>需要注意的是，这只是一个简化的例子，实际的实现可能更为复杂，以处理各种类型和体系结构。实际的 <code>sizeof</code> 实现通常是由编译器内部提供的，因为它需要考虑各种编译器和目标平台的特定细节。</p><h3 id="代码分析" tabindex="-1"><a class="header-anchor" href="#代码分析" aria-hidden="true">#</a> 代码分析</h3><p><code>(size_t)(&amp;((type*)0)[1])</code> 的运算顺序可以分解为以下步骤：</p><ol><li><code>(type*)0</code>: 将整数 0 转换为指向类型 <code>type</code> 的指针，得到一个指向类型 <code>type</code> 的空指针。</li><li><code>((type*)0)[1]</code>: 使用上一步得到的空指针进行数组操作，取得数组的第二个元素。这等效于 <code>( ((type*)0) + 1)</code>。请注意，这里并没有实际的数组，只是利用了指针运算的语法。</li><li><code>&amp;((type*)0)[1]</code>: 取得数组第二个元素的地址。</li><li><code>(size_t)(&amp;((type*)0)[1])</code>: 将这个地址转换为 <code>size_t</code> 类型。</li></ol><p>整个表达式的目的是计算一个指向类型 <code>type</code> 的指针，指向一个虚构的数组的第二个元素，然后获取这个元素的地址，并将其转换为 <code>size_t</code> 类型。这种技巧通常用于计算结构体或数组的大小，而无需创建实际的实例。</p><p>通过将test.c文件编译成汇编文件可发现：</p><p><code>SIZEOF(int)</code> 对应汇编文件中的 <code>movq $4, -8(%rbp)</code>，将值 4 存储在相对于 <strong><code>%rbp</code></strong> 偏移为 -8 的位置。</p><p><code>SIZEOF(double)</code> 对应汇编文件中的<code>movq $8, -8(%rbp)</code>，将值 8 存储在相对于 <strong><code>%rbp</code></strong> 偏移为 -8 的位置。</p><p>可见将整数 0 转换为指向类型 <code>type</code> 的指针，得到一个指向类型 <code>type</code> 的空指针时<code>type[0]</code>的地址为0，<code>((type*)0)[1]</code>的偏移量即为type的字节大小，从而可获取type的字节大小</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>若本文对您有用，欢迎送个表情包或评论 ;若有不对之处或建议，欢迎评论</p></div>`,18);function d(l,r){return e(),s("div",null,[t,a(" more "),i])}const m=n(p,[["render",d],["__file","sizeof_in_c.html.vue"]]);export{m as default};
