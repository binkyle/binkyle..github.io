const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const l of e.keys())if(l===F){const a=o[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=u;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=o[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=o[f+y]+ +b,A=o[f+y+1]+1,w=o[p+y]+1,L=o[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,o,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const l=new Map;l.set(u.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(u),e=l}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const l of Object.keys(u)){const a=u[l],h=e._fieldIds[l],m=o.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,o,u,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,o,u,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,o,u,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(u),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=k(u),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(u,d)),u=l,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),l=u.includes("#"),[a,h]=u.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>o.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(o.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in o)for(const c of o.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":63,\"nextId\":63,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-184f4da6\",\"2\":\"v-2e3eac9e\",\"3\":\"v-423739d0\",\"4\":\"v-423739d0#项目构建\",\"5\":\"v-423739d0#部署到gitpages\",\"6\":\"v-423739d0@0\",\"7\":\"v-423739d0@1\",\"8\":\"v-1b2393cc\",\"9\":\"v-1b2393cc#指令介绍\",\"10\":\"v-1b2393cc#设置代理\",\"11\":\"v-1b2393cc#取消代理\",\"12\":\"v-1b2393cc#生效优先级\",\"13\":\"v-1b2393cc#案例\",\"14\":\"v-1b2393cc@0\",\"15\":\"v-1b2393cc@1\",\"16\":\"v-e3fb8f4c\",\"17\":\"v-e3fb8f4c#can通信基本原理\",\"18\":\"v-e3fb8f4c#can通信概述\",\"19\":\"v-e3fb8f4c#can标准及原理图\",\"20\":\"v-e3fb8f4c#can特性\",\"21\":\"v-e3fb8f4c#can功能特性\",\"22\":\"v-e3fb8f4c#can系统构成\",\"23\":\"v-e3fb8f4c#autosar-can协议栈概述\",\"24\":\"v-e3fb8f4c#can-driver\",\"25\":\"v-e3fb8f4c#mcal相关配置\",\"26\":\"v-e3fb8f4c#cantrcv\",\"27\":\"v-e3fb8f4c#cantrcv-模式切换\",\"28\":\"v-e3fb8f4c#mcal配置\",\"29\":\"v-e3fb8f4c#autosar-can协议栈集成\",\"30\":\"v-e3fb8f4c#autosar-can调试策略\",\"31\":\"v-e3fb8f4c#参考链接\",\"32\":\"v-e3fb8f4c@0\",\"33\":\"v-e3fb8f4c@1\",\"34\":\"v-2080517e\",\"35\":\"v-2080517e#autosar技术标准框架\",\"36\":\"v-2080517e#adaptive-platform-ap\",\"37\":\"v-2080517e#classic-platform-cp\",\"38\":\"v-2080517e#foundation-fo\",\"39\":\"v-2080517e#fo部分所定义的通用特性\",\"40\":\"v-2080517e#ap、cp、fo间的关系\",\"41\":\"v-2080517e#cp-与-ap-的区别\",\"42\":\"v-2080517e#基于区域集中式ee架构的整车部署\",\"43\":\"v-2080517e#autosar标准制定方式\",\"44\":\"v-2080517e#autosar年度关键节点\",\"45\":\"v-2080517e#参考链接\",\"46\":\"v-2080517e@0\",\"47\":\"v-2080517e@1\",\"48\":\"v-b52f310a\",\"49\":\"v-b52f310a#前提\",\"50\":\"v-b52f310a#extern作用\",\"51\":\"v-b52f310a#案例-使用extern模拟面向对象编程\",\"52\":\"v-b52f310a@0\",\"53\":\"v-b52f310a@1\",\"54\":\"v-74885854\",\"55\":\"v-74885854#代码分析\",\"56\":\"v-74885854@0\",\"57\":\"v-74885854@1\",\"58\":\"v-145ac574\",\"59\":\"v-e34f5e90\",\"60\":\"v-4c71a48e\",\"61\":\"v-3f59ed0d\",\"62\":\"v-861dcd0e\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,2],\"2\":[1],\"3\":[1,6],\"4\":[1,2],\"5\":[1,32],\"6\":[null,null,1],\"7\":[null,null,2],\"8\":[1,4],\"9\":[1],\"10\":[1,12],\"11\":[1,13],\"12\":[1,13],\"13\":[1,20],\"14\":[null,null,1],\"15\":[null,null,2],\"16\":[2,4],\"17\":[1],\"18\":[1,28],\"19\":[1,31],\"20\":[1,27],\"21\":[1,14],\"22\":[1,4],\"23\":[2,10],\"24\":[2,6],\"25\":[1,6],\"26\":[1,9],\"27\":[2,8],\"28\":[1,8],\"29\":[2],\"30\":[2],\"31\":[1,9],\"32\":[null,null,1],\"33\":[null,null,2],\"34\":[1,1],\"35\":[1,2],\"36\":[4,15],\"37\":[4,25],\"38\":[3,3],\"39\":[1,9],\"40\":[3,2],\"41\":[4,56],\"42\":[1,4],\"43\":[1],\"44\":[1,8],\"45\":[1,9],\"46\":[null,null,1],\"47\":[null,null,2],\"48\":[1,1],\"49\":[1,7],\"50\":[1,37],\"51\":[2,72],\"52\":[null,null,1],\"53\":[null,null,2],\"54\":[1,52],\"55\":[1,55],\"56\":[null,null,1],\"57\":[null,null,2],\"58\":[1],\"59\":[1],\"60\":[1],\"61\":[2],\"62\":[2]},\"averageFieldLength\":[1.3939738660235554,13.83918589448476,0.6744985350462023],\"storedFields\":{\"0\":{\"h\":\"主页\"},\"1\":{\"h\":\"介绍页\",\"t\":[\"将你的个人介绍和档案放置在此处。\"]},\"2\":{\"h\":\"幻灯片页\"},\"3\":{\"h\":\"使用vuePress搭建博客并部署到gitpages上\",\"t\":[\"这里使用的是theme-hope主题，项目环境、构建、本地运行指令可参考下面这个链接。\"]},\"4\":{\"h\":\"项目构建\",\"t\":[\"参考链接 小白教程\"]},\"5\":{\"h\":\"部署到gitpages\",\"t\":[\"若参考上面项目构建链接，此时本地git仓库已初始化\",\"1.创建本地分支\",\"查看本地分支\",\"git branch \",\"创建本地分支\",\"git checkout -b master \",\"2.连接远程分支\",\"添加远程仓库的引用\",\"git remote add origin https://github.com/yourusername/myrepo.git \",\"3.提交本地分支到远程分支\",\"git push origin <local_branch>:<remote_branch> \",\"提示\",\"若本文对您有用，欢迎送个表情包或评论\\n;若有不对之处或建议，欢迎评论\"]},\"6\":{\"c\":[\"使用指南\"]},\"7\":{\"c\":[\"VuePress\",\"使用指南\"]},\"8\":{\"h\":\"github代理配置指南\",\"t\":[\"本文主要介绍github system、global、local三个级别的代理配置及优先级\"]},\"9\":{\"h\":\"指令介绍\"},\"10\":{\"h\":\"设置代理\",\"t\":[\"git config --global http.proxy http://127.0.0.1:[Port] git config --global https.proxy https://127.0.0.1:1080:[Port] \"]},\"11\":{\"h\":\"取消代理\",\"t\":[\"git config --global --unset http.proxy git config --global --unset https.proxy \",\"提示\",\"[Port]替换为你本地代理的端口 --global 可替换为--system、--local\"]},\"12\":{\"h\":\"生效优先级\",\"t\":[\"system级指的是程序级别的配置，配置文件在程序的配置目录中 global级是用户级别的配置，配置文件在用户目录中 local级是仓库级别的配置，配置文件在仓库下的.git目录中\",\"提示\",\"优先级：local > global > system\"]},\"13\":{\"h\":\"案例\",\"t\":[\"在一个git脚本中当执行取消代理指令\",\"Alt text\",\"遇到报错\",\"Alt text\",\"通过执行代理查看指令\",\"git config --global --get http.proxy git config --global --get https.proxy \",\"发现global级别配置了代理地址，取消global级别的代理配置后，问题解决\",\"提示\",\"若本文对您有用，欢迎送个表情包或评论\\n;若有不对之处或建议，欢迎评论\"]},\"14\":{\"c\":[\"使用指南\"]},\"15\":{\"c\":[\"github\",\"使用指南\"]},\"16\":{\"h\":\"Autosar can协议栈\",\"t\":[\"本文主要讲解Autosar CAN 协议栈原理、集成及相关调试策略\"]},\"17\":{\"h\":\"CAN通信基本原理\"},\"18\":{\"h\":\"CAN通信概述\",\"t\":[\"CAN（Controller Area Network）即控制器局域网络。由于其高性能、高可靠性、及独 特的设计，CAN越来越受到人们的重视。国外已有许多大公司的产品采用了这一技术。\",\"CAN最初是由德国的BOSCH公司为汽车监测、控制系统而设计的。现代汽车越来越多地采用电子装置控制，如发动机的定时、注油控制，加速、刹车控制（ASC）及复杂的抗锁定刹车系统（ABS）等。由于这些控制需检测及交换大量数据，采用硬接信号线的方式不但烦琐、昂贵，而且难以解决问题，采用CAN总线上述问题便得到很好地解决。\"]},\"19\":{\"h\":\"CAN标准及原理图\",\"t\":[\"CAN总线是一种用于在不同的ECU（电子控制单元）之间传输数据的线，CAN总线协议是一种ISO 国际标准化的串行通信协议，有 ISO-11898 和 ISO-11519两个系列。其定义有： ISO-11898 定义了通信速率为 125 kbps ~1Mbps 的高速 CAN 通信标准，属于闭环总线，传输速率可达1Mbps，总线长度 ≤ 40米，如下图。\",\"ISO11519 定义了通信速率为 10～125 kbps 的低速 CAN 通信标准，属于开环总线，传输速率为40kbps时，总线长度可达1000米，如下图。 \"]},\"20\":{\"h\":\"CAN特性\",\"t\":[\"传输速率最高可达1Mbps，距离最远可达10km\",\"通信介质选择灵活（双绞线、同轴电缆、光纤）\",\"采用双线差分信号\",\"协议本身对节点的数量没有限制\",\"总线上节点的数量可以动态改变，组网灵活\",\"短帧结构，传输时间短，受干扰概率低\",\"多主站结构，各节点平等，任一节点可在任一时刻主动发送\",\"非破坏性的基于优先级的总线仲裁\",\"优先级通过报文的标识符（ID）区分，报文标识符在网络中是唯一的 \",\"标识符描述了数据的含义\",\"某些特定的应用对标识符的分配进行了标准化\",\"广播发送报文，报文可以被所有节点同时接收\",\"根据需要可进行相关性报文过滤 \"]},\"21\":{\"h\":\"CAN功能特性\",\"t\":[\"CAN总线上，信号表现为电压形式，通过CAN_H和CAN_L线上的电位差来表示CAN信号，分为显性电平(dominant)和隐性电平(recessive)两种类型。其中显性电平规定为逻辑0，隐性电平则为逻辑1。其具体定义可通过下图来理解。 \"]},\"22\":{\"h\":\"CAN系统构成\",\"t\":[\"有两种，如下图；第三种是CAN收发器也集成到微控制器中 \"]},\"23\":{\"h\":\"AUTOSAR CAN协议栈概述\",\"t\":[\"Driver：主要包括CAN的Driver，以及根据外部的CAN的收\",\"HaedwareAbs：包括用于区分CAN通信的接口，接收／发送不同功能的PDU以及控制CAN收发器进行工作的Transceiver\",\"Services：包换CAN的状态管理以及PDU和信号的处理相关的模块 \"]},\"24\":{\"h\":\"CAN Driver\",\"t\":[\"MCU的CAN外设控制模块\",\"主要数处理CAN的控制器中的功能，实现 数据在MCU CAN模块的收发 \"]},\"25\":{\"h\":\"MCAL相关配置\",\"t\":[\"CanGeneral：配置一些API的使能函数周期等\",\"CanController：配置MCU的CAN外设操作功能以及CAN的Filter\",\"CanHaradwareObject：配置CAN的接收发送邮箱以及使用的Filter\"]},\"26\":{\"h\":\"CANTrcv\",\"t\":[\"CAN Trcv模块主要控制CAN外部收发器的模式，MCU的CAN信号与CAN总线建立起数据交互;目标是为适用于大多数当前和未来CAN收发器设备定义接口和行为。CAN Trcv抽象了CAN收发器硬件。它为更高层提供了一个独立于硬件的接口。 它通过使用MCAL层的API来访问CAN收发器硬件，以便实现ECU布局中的抽象化。 \"]},\"27\":{\"h\":\"CANTrcv 模式切换\",\"t\":[\"CANTrcv的模式转换主要通过控制Dio或者SPI来控制硬件Trcv\",\"上电调用Init可以直接切换到任意一个模式\",\"SetMode函数用于被MainFunction或者CANIf接口调用控制\",\"在支持唤醒的Trcv一定要确保下电进入Sleep，才能有唤醒功能，这个时候Trcv处于常电模式，且唤醒中断引脚连接SBC的唤醒引脚 \"]},\"28\":{\"h\":\"MCAL配置\",\"t\":[\"·General：主要配置相关API的使能以及是否支持唤醒等功能 ·ConfigSet：根据外部电路配置Trcv的通道，主要分为DIO控制的和SPI控制的，DIO控制的根据使用的PIN关联到DIO通道，SPI控制的要分配SPI的Sequence\"]},\"29\":{\"h\":\"AUTOSAR CAN协议栈集成\"},\"30\":{\"h\":\"AUTOSAR CAN调试策略\"},\"31\":{\"h\":\"参考链接\",\"t\":[\"AUTOSAR_TR_FoundationReleaseOverview AUTOSAR中国官方培训课程\",\"提示\",\"若本文对您有用，欢迎送个表情包或评论\\n;若有不对之处或建议，欢迎评论\"]},\"32\":{\"c\":[\"Autosar\"]},\"33\":{\"c\":[\"CAN\",\"协议\"]},\"34\":{\"h\":\"Autosar解决方案概述\",\"t\":[\"本文主要讲解Autosar解决方案相关内容\"]},\"35\":{\"h\":\"Autosar技术标准框架\",\"t\":[\"AUTOSAR技术标准针对不同的需求提供了不同的解决方案，以涵盖汽车软件开发领域的各种应用场景\"]},\"36\":{\"h\":\"Adaptive Platform(AP)\",\"t\":[\"Adaptive Platform是AUTOSAR为开发安全相关的高算力ECU，如自动驾驶，而提供的解决方案\",\"AP分层软件架构特点:\",\"支持采用C++作为应用软件的编程语言\",\"采用面向服务的架构（SOA）\",\"支持多任务并行处理\",\"尽可能重用已有标准\",\"支持功能安全和信息安全\",\"有计划的动态性，而非完全动态\",\"支持基于敏捷的开发过程 \"]},\"37\":{\"h\":\"Classic Platform(CP)\",\"t\":[\"Classic Platform是AUTOSAR为开发硬实时、高安全性嵌入式系统，如电驱控制，而提供的解决方案\",\"CP分层软件架构支持：\",\"对硬件进行抽象，实现软硬解耦\",\"对Runnable和Task进行调度（操作系统）\",\"抽象部署在同一ECU或者不同ECU上的应用之间的通信，实现整车层面的虚拟功能总线\",\"故障诊断及诊断服务\",\"功能安全服务\",\"今信息安全服务 \",\"CP所定义的系统服务、存储、通信、硬件1/0和复杂驱动等各个基础软件技术栈，其作用类似于人体的神经系统。相对应地，控制器硬件可以理解为身体，而应用软件可以理解为大脑或灵魂。 \"]},\"38\":{\"h\":\"Foundation(FO)\",\"t\":[\"Foundation包含了AP和CP之间通用的内容以保证二者之间以及二者与非AUTOSAR系统之间的兼容性\",\"原文如下： \"]},\"39\":{\"h\":\"FO部分所定义的通用特性\",\"t\":[\"FO部分所定义的内容为“基础设施”，同时适用于CP和AP两种系统，以保证二者之间的兼容性。如通信协议、元模型、主干需求与术语、文件模板等。\"]},\"40\":{\"h\":\"AP、CP、FO间的关系\",\"t\":[\"Alt text\"]},\"41\":{\"h\":\"CP 与 AP 的区别\",\"t\":[\"CP\",\"AP\",\"Based on OSEK\",\"Based on POSIX\",\"Execution of code directly from ROM\",\"App is loaded from persistent memory into RAM\",\"Same address space for all applications (MPU support for safety)\",\"Each application has its own (virtual) address space (MMU support)\",\"Optimized for signal-based communication (CAN, FlexRay)\",\"Service-oriented communication\",\"Fixed task configuration\",\"Support of multiple (dynamic) scheduling strategies\",\"Specification\",\"Specification and code\",\"从CP到AP,实时性与安全性需求减少，算力需求增加\"]},\"42\":{\"h\":\"基于区域集中式EE架构的整车部署\",\"t\":[\" CP应用范围更广，AP与CP相辅相成，AP不会替代AP\"]},\"43\":{\"h\":\"Autosar标准制定方式\"},\"44\":{\"h\":\"AUTOSAR年度关键节点\",\"t\":[\"每年11月份集中发布FO、CP和AP标准\",\"AP演示代码在次年春季发布\",\"每年上半年举办开放大会AOC\",\"每年12月份组织标准发布会\",\"年中组织全体工作组会议\",\"Alt text\"]},\"45\":{\"h\":\"参考链接\",\"t\":[\"AUTOSAR_TR_FoundationReleaseOverview AUTOSAR中国官方培训课程\",\"提示\",\"若本文对您有用，欢迎送个表情包或评论\\n;若有不对之处或建议，欢迎评论\"]},\"46\":{\"c\":[\"Autosar\"]},\"47\":{\"c\":[\"概述\",\"解决方案\"]},\"48\":{\"h\":\"C语言extern关键字作用分析\",\"t\":[\"本文主要介绍C语言中extern的作用分析\"]},\"49\":{\"h\":\"前提\",\"t\":[\"首先理解声明和定义：\",\"声明是告诉编译器有一个这样的变量或函数存在，定义是为变量分配内存空间或者实现函数本体(body)\",\"提示\",\"在c语言中声明和定义一个变量是同时进行的，但extern仅用于声明\"]},\"50\":{\"h\":\"extern作用\",\"t\":[\"在C语言中，关键字extern用于声明一个变量或函数，以便告诉编译器它们的存在，但并不会分配实际的存储空间。具体来说，extern的作用有以下几点：\",\"变量声明：当extern用于变量声明时，它告诉编译器该变量在其他文件中已经定义，因此在当前文件中不需要为其分配存储空间。这样做可以避免重复定义变量，而只是声明它的存在。\",\"// 在一个文件中声明变量 extern int x; \",\"函数声明：类似地，extern也可以用于函数声明，以便告诉编译器该函数在其他文件中已经定义。\",\"// 声明函数的存在 extern void someFunction(); \",\"全局变量：在全局范围内使用extern可以使变量在当前文件中具有全局作用域，但实际的定义在其他文件中。这在大型项目中很有用，因为它允许多个文件共享相同的全局变量。\",\"// 在一个文件中使用 extern 声明全局变量 extern int globalVariable; \",\"总之，extern关键字用于声明变量或函数的存在，但不会分配实际的存储空间。这使得程序可以跨多个文件共享变量和函数，同时避免了重复定义的问题。\"]},\"51\":{\"h\":\"案例： 使用extern模拟面向对象编程\",\"t\":[\"在C语言中，使用extern关键字可以实现一定程度的面向对象编程。下面是一个详细的例子，展示了如何使用extern来模拟类和对象的概念。\",\"首先，我们创建一个头文件myclass.h，其中定义了一个类MyClass和相关的方法和属性：\",\"// myclass.h #ifndef MYCLASS_H #define MYCLASS_H typedef struct { int data; void (*printData)(); } MyClass; extern MyClass myObject; void MyClass_init(); void MyClass_printData(); #endif \",\"然后，我们创建一个源文件myclass.c，实现了类的初始化和打印数据的方法：\",\"// myclass.c #include <stdio.h> #include \\\"myclass.h\\\" MyClass myObject; void MyClass_init() { myObject.data = 2023; myObject.printData = MyClass_printData; } void MyClass_printData() { printf(\\\"Data: %d\\\\\\\\n\\\", myObject.data); } \",\"接下来，我们创建一个主文件main.c，在其中使用类和对象：\",\"// main.c #include \\\"myclass.h\\\" extern MyClass myObject; int main() { MyClass_init(); myObject.printData(); return 0; } \",\"运行结果\",\"运行结果图\",\"在这个例子中，我们使用extern关键字在main.c中引用了在myclass.c中定义的myObject对象。通过调用MyClass_init()方法初始化对象，并通过myObject.printData()调用对象的方法。\",\"编译这些文件并运行程序，你将看到输出结果为Data: 2023，表示成功使用extern实现了面向对象编程的模拟。\",\"需要注意的是，虽然使用extern可以模拟类和对象的概念，但C语言本身并不直接支持面向对象编程。这只是一种基于C语言的技巧或模式来实现一些面向对象的思想。\",\"参考链接： Difference between Definition and Declaration - GeeksforGeeks\",\"提示\",\"若本文对您有用，欢迎送个表情包或评论\\n;若有不对之处或建议，欢迎评论\"]},\"52\":{\"c\":[\"编程语言\"]},\"53\":{\"c\":[\"C语言\",\"extern\"]},\"54\":{\"h\":\"C语言sizeof宏分析\",\"t\":[\"本文主要介绍C语言中sizeof的原理分析\",\"sizeof 是 C 语言的一个运算符，用于返回一个对象或数据类型的大小，以字节为单位。sizeof 运算符在编译时计算，不会执行实际的运算。\",\"由于 sizeof 是编译时计算大小的，其实现是由编译器提供的，而不是由标准 C 库提供的函数。因此，sizeof 的实现通常依赖于编译器和目标体系结构。\",\"以下是 sizeof 运算符的一种可能的简化实现，假设一个字节等于 8 比特：\",\"test.c文件\",\"#define SIZEOF(type) ((size_t)(&((type*)0)[1])) // 示例用法 int main() { size_t size = SIZEOF(int); return 0; } \",\"这个宏的工作原理是，将一个空指针转换为类型 type*，然后取数组的第一个元素的地址。由于数组索引是从零开始的，&((type*)0)[1] 计算出第一个元素之后的地址。然后，整个表达式被强制转换为 size_t 类型，以表示大小。\",\"需要注意的是，这只是一个简化的例子，实际的实现可能更为复杂，以处理各种类型和体系结构。实际的 sizeof 实现通常是由编译器内部提供的，因为它需要考虑各种编译器和目标平台的特定细节。\"]},\"55\":{\"h\":\"代码分析\",\"t\":[\"(size_t)(&((type*)0)[1]) 的运算顺序可以分解为以下步骤：\",\"(type*)0: 将整数 0 转换为指向类型 type 的指针，得到一个指向类型 type 的空指针。\",\"((type*)0)[1]: 使用上一步得到的空指针进行数组操作，取得数组的第二个元素。这等效于 ( ((type*)0) + 1)。请注意，这里并没有实际的数组，只是利用了指针运算的语法。\",\"&((type*)0)[1]: 取得数组第二个元素的地址。\",\"(size_t)(&((type*)0)[1]): 将这个地址转换为 size_t 类型。\",\"整个表达式的目的是计算一个指向类型 type 的指针，指向一个虚构的数组的第二个元素，然后获取这个元素的地址，并将其转换为 size_t 类型。这种技巧通常用于计算结构体或数组的大小，而无需创建实际的实例。\",\"通过将test.c文件编译成汇编文件可发现：\",\"SIZEOF(int) 对应汇编文件中的 movq $4, -8(%rbp)，将值 4 存储在相对于 %rbp 偏移为 -8 的位置。\",\"SIZEOF(double) 对应汇编文件中的movq $8, -8(%rbp)，将值 8 存储在相对于 %rbp 偏移为 -8 的位置。\",\"可见将整数 0 转换为指向类型 type 的指针，得到一个指向类型 type 的空指针时type[0]的地址为0，((type*)0)[1]的偏移量即为type的字节大小，从而可获取type的字节大小\",\"提示\",\"若本文对您有用，欢迎送个表情包或评论\\n;若有不对之处或建议，欢迎评论\"]},\"56\":{\"c\":[\"编程语言\"]},\"57\":{\"c\":[\"C语言\",\"siezof\"]},\"58\":{\"h\":\"Blog\"},\"59\":{\"h\":\"Github\"},\"60\":{\"h\":\"Autosar\"},\"61\":{\"h\":\"C Cplusplus\"},\"62\":{\"h\":\"Programming Language\"}},\"dirtCount\":0,\"index\":[[\"从而可获取type的字节大小\",{\"1\":{\"55\":1}}],[\"从cp到ap\",{\"1\":{\"41\":1}}],[\"可见将整数\",{\"1\":{\"55\":1}}],[\"可替换为\",{\"1\":{\"11\":1}}],[\"$8\",{\"1\":{\"55\":1}}],[\"$4\",{\"1\":{\"55\":1}}],[\"偏移为\",{\"1\":{\"55\":2}}],[\"4\",{\"1\":{\"55\":1}}],[\"40米\",{\"1\":{\"19\":1}}],[\"并将其转换为\",{\"1\":{\"55\":1}}],[\"并通过myobject\",{\"1\":{\"51\":1}}],[\"指向一个虚构的数组的第二个元素\",{\"1\":{\"55\":1}}],[\"指令介绍\",{\"0\":{\"9\":1}}],[\"整个表达式的目的是计算一个指向类型\",{\"1\":{\"55\":1}}],[\"整个表达式被强制转换为\",{\"1\":{\"54\":1}}],[\"只是利用了指针运算的语法\",{\"1\":{\"55\":1}}],[\"请注意\",{\"1\":{\"55\":1}}],[\"+\",{\"1\":{\"55\":1}}],[\"取得数组第二个元素的地址\",{\"1\":{\"55\":1}}],[\"取得数组的第二个元素\",{\"1\":{\"55\":1}}],[\"取消global级别的代理配置后\",{\"1\":{\"13\":1}}],[\"取消代理\",{\"0\":{\"11\":1}}],[\"得到一个指向类型\",{\"1\":{\"55\":2}}],[\"转换为指向类型\",{\"1\":{\"55\":2}}],[\"代码分析\",{\"0\":{\"55\":1}}],[\"类型\",{\"1\":{\"54\":1,\"55\":2}}],[\"类似地\",{\"1\":{\"50\":1}}],[\"计算出第一个元素之后的地址\",{\"1\":{\"54\":1}}],[\"将值\",{\"1\":{\"55\":2}}],[\"将这个地址转换为\",{\"1\":{\"55\":1}}],[\"将整数\",{\"1\":{\"55\":1}}],[\"将一个空指针转换为类型\",{\"1\":{\"54\":1}}],[\"将你的个人介绍和档案放置在此处\",{\"1\":{\"1\":1}}],[\"示例用法\",{\"1\":{\"54\":1}}],[\"比特\",{\"1\":{\"54\":1}}],[\"8\",{\"1\":{\"54\":1,\"55\":5}}],[\"假设一个字节等于\",{\"1\":{\"54\":1}}],[\"库提供的函数\",{\"1\":{\"54\":1}}],[\"不会执行实际的运算\",{\"1\":{\"54\":1}}],[\"运算符的一种可能的简化实现\",{\"1\":{\"54\":1}}],[\"运算符在编译时计算\",{\"1\":{\"54\":1}}],[\"运行结果图\",{\"1\":{\"51\":1}}],[\"运行结果\",{\"1\":{\"51\":1}}],[\"用于返回一个对象或数据类型的大小\",{\"1\":{\"54\":1}}],[\"语言的一个运算符\",{\"1\":{\"54\":1}}],[\"是编译时计算大小的\",{\"1\":{\"54\":1}}],[\"是\",{\"1\":{\"54\":1}}],[\"编程语言\",{\"2\":{\"52\":1,\"56\":1}}],[\"编译这些文件并运行程序\",{\"1\":{\"51\":1}}],[\"虽然使用extern可以模拟类和对象的概念\",{\"1\":{\"51\":1}}],[\"需要注意的是\",{\"1\":{\"51\":1,\"54\":1}}],[\"表示成功使用extern实现了面向对象编程的模拟\",{\"1\":{\"51\":1}}],[\"你将看到输出结果为data\",{\"1\":{\"51\":1}}],[\"调用对象的方法\",{\"1\":{\"51\":1}}],[\"方法初始化对象\",{\"1\":{\"51\":1}}],[\"我们使用extern关键字在main\",{\"1\":{\"51\":1}}],[\"我们创建一个主文件main\",{\"1\":{\"51\":1}}],[\"我们创建一个源文件myclass\",{\"1\":{\"51\":1}}],[\"我们创建一个头文件myclass\",{\"1\":{\"51\":1}}],[\"接下来\",{\"1\":{\"51\":1}}],[\"接收\",{\"1\":{\"23\":1}}],[\"n\",{\"1\":{\"51\":1}}],[\"network\",{\"1\":{\"18\":1}}],[\"=\",{\"1\":{\"51\":2,\"54\":1}}],[\"然后获取这个元素的地址\",{\"1\":{\"55\":1}}],[\"然后取数组的第一个元素的地址\",{\"1\":{\"54\":1}}],[\"然后\",{\"1\":{\"51\":1,\"54\":1}}],[\"首先\",{\"1\":{\"51\":1}}],[\"首先理解声明和定义\",{\"1\":{\"49\":1}}],[\"展示了如何使用extern来模拟类和对象的概念\",{\"1\":{\"51\":1}}],[\"下面是一个详细的例子\",{\"1\":{\"51\":1}}],[\"总之\",{\"1\":{\"50\":1}}],[\"总线上节点的数量可以动态改变\",{\"1\":{\"20\":1}}],[\"总线长度可达1000米\",{\"1\":{\"19\":1}}],[\"总线长度\",{\"1\":{\"19\":1}}],[\"因为它需要考虑各种编译器和目标平台的特定细节\",{\"1\":{\"54\":1}}],[\"因为它允许多个文件共享相同的全局变量\",{\"1\":{\"50\":1}}],[\"因此\",{\"1\":{\"54\":1}}],[\"因此在当前文件中不需要为其分配存储空间\",{\"1\":{\"50\":1}}],[\"全局变量\",{\"1\":{\"50\":1}}],[\"声明全局变量\",{\"1\":{\"50\":1}}],[\"声明函数的存在\",{\"1\":{\"50\":1}}],[\"声明是告诉编译器有一个这样的变量或函数存在\",{\"1\":{\"49\":1}}],[\"函数声明\",{\"1\":{\"50\":1}}],[\"x\",{\"1\":{\"50\":1}}],[\"当extern用于变量声明时\",{\"1\":{\"50\":1}}],[\"变量声明\",{\"1\":{\"50\":1}}],[\"具体来说\",{\"1\":{\"50\":1}}],[\"但c语言本身并不直接支持面向对象编程\",{\"1\":{\"51\":1}}],[\"但不会分配实际的存储空间\",{\"1\":{\"50\":1}}],[\"但实际的定义在其他文件中\",{\"1\":{\"50\":1}}],[\"但并不会分配实际的存储空间\",{\"1\":{\"50\":1}}],[\"但extern仅用于声明\",{\"1\":{\"49\":1}}],[\"关键字extern用于声明一个变量或函数\",{\"1\":{\"50\":1}}],[\"定义是为变量分配内存空间或者实现函数本体\",{\"1\":{\"49\":1}}],[\"定义了通信速率为\",{\"1\":{\"19\":2}}],[\"前提\",{\"0\":{\"49\":1}}],[\"解决方案\",{\"2\":{\"47\":1}}],[\"概述\",{\"2\":{\"47\":1}}],[\"年中组织全体工作组会议\",{\"1\":{\"44\":1}}],[\"每年12月份组织标准发布会\",{\"1\":{\"44\":1}}],[\"每年11月份集中发布fo\",{\"1\":{\"44\":1}}],[\"每年上半年举办开放大会aoc\",{\"1\":{\"44\":1}}],[\"基于区域集中式ee架构的整车部署\",{\"0\":{\"42\":1}}],[\"基础设施\",{\"1\":{\"39\":1}}],[\"算力需求增加\",{\"1\":{\"41\":1}}],[\"实际的\",{\"1\":{\"54\":1}}],[\"实际的实现可能更为复杂\",{\"1\":{\"54\":1}}],[\"实时性与安全性需求减少\",{\"1\":{\"41\":1}}],[\"实现通常是由编译器内部提供的\",{\"1\":{\"54\":1}}],[\"实现了类的初始化和打印数据的方法\",{\"1\":{\"51\":1}}],[\"实现整车层面的虚拟功能总线\",{\"1\":{\"37\":1}}],[\"实现软硬解耦\",{\"1\":{\"37\":1}}],[\"实现\",{\"1\":{\"24\":1}}],[\"void\",{\"1\":{\"50\":1,\"51\":5}}],[\"virtual\",{\"1\":{\"41\":1}}],[\"vuepress\",{\"2\":{\"7\":1}}],[\"endif\",{\"1\":{\"51\":1}}],[\"extern关键字用于声明变量或函数的存在\",{\"1\":{\"50\":1}}],[\"extern也可以用于函数声明\",{\"1\":{\"50\":1}}],[\"extern\",{\"1\":{\"50\":4,\"51\":2},\"2\":{\"53\":1}}],[\"extern的作用有以下几点\",{\"1\":{\"50\":1}}],[\"extern作用\",{\"0\":{\"50\":1}}],[\"execution\",{\"1\":{\"41\":1}}],[\"each\",{\"1\":{\"41\":1}}],[\"rbp\",{\"1\":{\"55\":4}}],[\"ram\",{\"1\":{\"41\":1}}],[\"rom\",{\"1\":{\"41\":1}}],[\"return\",{\"1\":{\"51\":1,\"54\":1}}],[\"recessive\",{\"1\":{\"21\":1}}],[\"remote\",{\"1\":{\"5\":1}}],[\"fixed\",{\"1\":{\"41\":1}}],[\"flexray\",{\"1\":{\"41\":1}}],[\"from\",{\"1\":{\"41\":2}}],[\"for\",{\"1\":{\"41\":3}}],[\"fo间的关系\",{\"0\":{\"40\":1}}],[\"fo部分所定义的内容为\",{\"1\":{\"39\":1}}],[\"fo部分所定义的通用特性\",{\"0\":{\"39\":1}}],[\"fo\",{\"0\":{\"38\":1}}],[\"foundation包含了ap和cp之间通用的内容以保证二者之间以及二者与非autosar系统之间的兼容性\",{\"1\":{\"38\":1}}],[\"foundation\",{\"0\":{\"38\":1}}],[\"foundationreleaseoverview\",{\"1\":{\"31\":1,\"45\":1}}],[\"oriented\",{\"1\":{\"41\":1}}],[\"origin\",{\"1\":{\"5\":2}}],[\"optimized\",{\"1\":{\"41\":1}}],[\"own\",{\"1\":{\"41\":1}}],[\"of\",{\"1\":{\"41\":2}}],[\"osek\",{\"1\":{\"41\":1}}],[\"on\",{\"1\":{\"41\":2}}],[\"与\",{\"0\":{\"41\":1}}],[\"文件模板等\",{\"1\":{\"39\":1}}],[\"元模型\",{\"1\":{\"39\":1}}],[\"同时避免了重复定义的问题\",{\"1\":{\"50\":1}}],[\"同时适用于cp和ap两种系统\",{\"1\":{\"39\":1}}],[\"同轴电缆\",{\"1\":{\"20\":1}}],[\"原文如下\",{\"1\":{\"38\":1}}],[\"控制器硬件可以理解为身体\",{\"1\":{\"37\":1}}],[\"控制系统而设计的\",{\"1\":{\"18\":1}}],[\"相对应地\",{\"1\":{\"37\":1}}],[\"硬件1\",{\"1\":{\"37\":1}}],[\"存储在相对于\",{\"1\":{\"55\":2}}],[\"存储\",{\"1\":{\"37\":1}}],[\"今信息安全服务\",{\"1\":{\"37\":1}}],[\"功能安全服务\",{\"1\":{\"37\":1}}],[\"故障诊断及诊断服务\",{\"1\":{\"37\":1}}],[\"抽象部署在同一ecu或者不同ecu上的应用之间的通信\",{\"1\":{\"37\":1}}],[\"操作系统\",{\"1\":{\"37\":1}}],[\"对应汇编文件中的movq\",{\"1\":{\"55\":1}}],[\"对应汇编文件中的\",{\"1\":{\"55\":1}}],[\"对runnable和task进行调度\",{\"1\":{\"37\":1}}],[\"对硬件进行抽象\",{\"1\":{\"37\":1}}],[\"高安全性嵌入式系统\",{\"1\":{\"37\":1}}],[\"高可靠性\",{\"1\":{\"18\":1}}],[\"尽可能重用已有标准\",{\"1\":{\"36\":1}}],[\"支持基于敏捷的开发过程\",{\"1\":{\"36\":1}}],[\"支持功能安全和信息安全\",{\"1\":{\"36\":1}}],[\"支持多任务并行处理\",{\"1\":{\"36\":1}}],[\"支持采用c++作为应用软件的编程语言\",{\"1\":{\"36\":1}}],[\"而无需创建实际的实例\",{\"1\":{\"55\":1}}],[\"而不是由标准\",{\"1\":{\"54\":1}}],[\"而只是声明它的存在\",{\"1\":{\"50\":1}}],[\"而应用软件可以理解为大脑或灵魂\",{\"1\":{\"37\":1}}],[\"而非完全动态\",{\"1\":{\"36\":1}}],[\"而提供的解决方案\",{\"1\":{\"36\":1,\"37\":1}}],[\"而且难以解决问题\",{\"1\":{\"18\":1}}],[\"根据外部电路配置trcv的通道\",{\"1\":{\"28\":1}}],[\"根据需要可进行相关性报文过滤\",{\"1\":{\"20\":1}}],[\"且唤醒中断引脚连接sbc的唤醒引脚\",{\"1\":{\"27\":1}}],[\"这种技巧通常用于计算结构体或数组的大小\",{\"1\":{\"55\":1}}],[\"这里并没有实际的数组\",{\"1\":{\"55\":1}}],[\"这里使用的是theme\",{\"1\":{\"3\":1}}],[\"这等效于\",{\"1\":{\"55\":1}}],[\"这只是一个简化的例子\",{\"1\":{\"54\":1}}],[\"这只是一种基于c语言的技巧或模式来实现一些面向对象的思想\",{\"1\":{\"51\":1}}],[\"这个宏的工作原理是\",{\"1\":{\"54\":1}}],[\"这个时候trcv处于常电模式\",{\"1\":{\"27\":1}}],[\"这使得程序可以跨多个文件共享变量和函数\",{\"1\":{\"50\":1}}],[\"这在大型项目中很有用\",{\"1\":{\"50\":1}}],[\"这样做可以避免重复定义变量\",{\"1\":{\"50\":1}}],[\"才能有唤醒功能\",{\"1\":{\"27\":1}}],[\"在这个例子中\",{\"1\":{\"51\":1}}],[\"在其中使用类和对象\",{\"1\":{\"51\":1}}],[\"在全局范围内使用extern可以使变量在当前文件中具有全局作用域\",{\"1\":{\"50\":1}}],[\"在一个文件中使用\",{\"1\":{\"50\":1}}],[\"在一个文件中声明变量\",{\"1\":{\"50\":1}}],[\"在一个git脚本中当执行取消代理指令\",{\"1\":{\"13\":1}}],[\"在c语言中\",{\"1\":{\"50\":1,\"51\":1}}],[\"在c语言中声明和定义一个变量是同时进行的\",{\"1\":{\"49\":1}}],[\"在支持唤醒的trcv一定要确保下电进入sleep\",{\"1\":{\"27\":1}}],[\"上电调用init可以直接切换到任意一个模式\",{\"1\":{\"27\":1}}],[\"模式切换\",{\"0\":{\"27\":1}}],[\"以处理各种类型和体系结构\",{\"1\":{\"54\":1}}],[\"以表示大小\",{\"1\":{\"54\":1}}],[\"以下是\",{\"1\":{\"54\":1}}],[\"以字节为单位\",{\"1\":{\"54\":1}}],[\"以便告诉编译器该函数在其他文件中已经定义\",{\"1\":{\"50\":1}}],[\"以便告诉编译器它们的存在\",{\"1\":{\"50\":1}}],[\"以便实现ecu布局中的抽象化\",{\"1\":{\"26\":1}}],[\"以保证二者之间的兼容性\",{\"1\":{\"39\":1}}],[\"以涵盖汽车软件开发领域的各种应用场景\",{\"1\":{\"35\":1}}],[\"以及根据外部的can的收\",{\"1\":{\"23\":1}}],[\"它告诉编译器该变量在其他文件中已经定义\",{\"1\":{\"50\":1}}],[\"它通过使用mcal层的api来访问can收发器硬件\",{\"1\":{\"26\":1}}],[\"它为更高层提供了一个独立于硬件的接口\",{\"1\":{\"26\":1}}],[\"目标是为适用于大多数当前和未来can收发器设备定义接口和行为\",{\"1\":{\"26\":1}}],[\"t\",{\"1\":{\"54\":3,\"55\":4}}],[\"type\",{\"1\":{\"54\":4,\"55\":12}}],[\"typedef\",{\"1\":{\"51\":1}}],[\"test\",{\"1\":{\"54\":1}}],[\"text\",{\"1\":{\"13\":2,\"40\":1,\"44\":1}}],[\"task\",{\"1\":{\"41\":1}}],[\"tr\",{\"1\":{\"31\":1,\"45\":1}}],[\"trcv抽象了can收发器硬件\",{\"1\":{\"26\":1}}],[\"trcv模块主要控制can外部收发器的模式\",{\"1\":{\"26\":1}}],[\"配置can的接收发送邮箱以及使用的filter\",{\"1\":{\"25\":1}}],[\"配置mcu的can外设操作功能以及can的filter\",{\"1\":{\"25\":1}}],[\"配置一些api的使能函数周期等\",{\"1\":{\"25\":1}}],[\"配置文件在仓库下的\",{\"1\":{\"12\":1}}],[\"配置文件在用户目录中\",{\"1\":{\"12\":1}}],[\"配置文件在程序的配置目录中\",{\"1\":{\"12\":1}}],[\"数据在mcu\",{\"1\":{\"24\":1}}],[\"包换can的状态管理以及pdu和信号的处理相关的模块\",{\"1\":{\"23\":1}}],[\"包括用于区分can通信的接口\",{\"1\":{\"23\":1}}],[\"siezof\",{\"2\":{\"57\":1}}],[\"size\",{\"1\":{\"54\":4,\"55\":4}}],[\"sizeof\",{\"1\":{\"54\":8,\"55\":2}}],[\"signal\",{\"1\":{\"41\":1}}],[\"struct\",{\"1\":{\"51\":1}}],[\"strategies\",{\"1\":{\"41\":1}}],[\"somefunction\",{\"1\":{\"50\":1}}],[\"soa\",{\"1\":{\"36\":1}}],[\"scheduling\",{\"1\":{\"41\":1}}],[\"safety\",{\"1\":{\"41\":1}}],[\"same\",{\"1\":{\"41\":1}}],[\"support\",{\"1\":{\"41\":3}}],[\"specification\",{\"1\":{\"41\":2}}],[\"space\",{\"1\":{\"41\":2}}],[\"spi控制的要分配spi的sequence\",{\"1\":{\"28\":1}}],[\"service\",{\"1\":{\"41\":1}}],[\"services\",{\"1\":{\"23\":1}}],[\"setmode函数用于被mainfunction或者canif接口调用控制\",{\"1\":{\"27\":1}}],[\"system级指的是程序级别的配置\",{\"1\":{\"12\":1}}],[\"system\",{\"1\":{\"8\":1,\"11\":1,\"12\":1}}],[\"发送不同功能的pdu以及控制can收发器进行工作的transceiver\",{\"1\":{\"23\":1}}],[\"发现global级别配置了代理地址\",{\"1\":{\"13\":1}}],[\"主干需求与术语\",{\"1\":{\"39\":1}}],[\"主要分为dio控制的和spi控制的\",{\"1\":{\"28\":1}}],[\"主要配置相关api的使能以及是否支持唤醒等功能\",{\"1\":{\"28\":1}}],[\"主要数处理can的控制器中的功能\",{\"1\":{\"24\":1}}],[\"主要包括can的driver\",{\"1\":{\"23\":1}}],[\"主页\",{\"0\":{\"0\":1}}],[\"double\",{\"1\":{\"55\":1}}],[\"dominant\",{\"1\":{\"21\":1}}],[\"declaration\",{\"1\":{\"51\":1}}],[\"definition\",{\"1\":{\"51\":1}}],[\"define\",{\"1\":{\"51\":1,\"54\":1}}],[\"d\",{\"1\":{\"51\":1}}],[\"data\",{\"1\":{\"51\":4}}],[\"dynamic\",{\"1\":{\"41\":1}}],[\"difference\",{\"1\":{\"51\":1}}],[\"directly\",{\"1\":{\"41\":1}}],[\"dio控制的根据使用的pin关联到dio通道\",{\"1\":{\"28\":1}}],[\"driver\",{\"0\":{\"24\":1},\"1\":{\"23\":1}}],[\"第三种是can收发器也集成到微控制器中\",{\"1\":{\"22\":1}}],[\"隐性电平则为逻辑1\",{\"1\":{\"21\":1}}],[\"其实现是由编译器提供的\",{\"1\":{\"54\":1}}],[\"其中定义了一个类myclass和相关的方法和属性\",{\"1\":{\"51\":1}}],[\"其中显性电平规定为逻辑0\",{\"1\":{\"21\":1}}],[\"其作用类似于人体的神经系统\",{\"1\":{\"37\":1}}],[\"其具体定义可通过下图来理解\",{\"1\":{\"21\":1}}],[\"其定义有\",{\"1\":{\"19\":1}}],[\"两种类型\",{\"1\":{\"21\":1}}],[\"分为显性电平\",{\"1\":{\"21\":1}}],[\"language\",{\"0\":{\"62\":1}}],[\"loaded\",{\"1\":{\"41\":1}}],[\"local级是仓库级别的配置\",{\"1\":{\"12\":1}}],[\"local\",{\"1\":{\"11\":1,\"12\":1}}],[\"local三个级别的代理配置及优先级\",{\"1\":{\"8\":1}}],[\"l线上的电位差来表示can信号\",{\"1\":{\"21\":1}}],[\"信号表现为电压形式\",{\"1\":{\"21\":1}}],[\"报文可以被所有节点同时接收\",{\"1\":{\"20\":1}}],[\"报文标识符在网络中是唯一的\",{\"1\":{\"20\":1}}],[\"广播发送报文\",{\"1\":{\"20\":1}}],[\"某些特定的应用对标识符的分配进行了标准化\",{\"1\":{\"20\":1}}],[\"标识符描述了数据的含义\",{\"1\":{\"20\":1}}],[\"区分\",{\"1\":{\"20\":1}}],[\"include\",{\"1\":{\"51\":3}}],[\"init\",{\"1\":{\"51\":4}}],[\"int\",{\"1\":{\"50\":2,\"51\":2,\"54\":2,\"55\":1}}],[\"into\",{\"1\":{\"41\":1}}],[\"ifndef\",{\"1\":{\"51\":1}}],[\"its\",{\"1\":{\"41\":1}}],[\"is\",{\"1\":{\"41\":1}}],[\"iso11519\",{\"1\":{\"19\":1}}],[\"iso\",{\"1\":{\"19\":3}}],[\"id\",{\"1\":{\"20\":1}}],[\"非破坏性的基于优先级的总线仲裁\",{\"1\":{\"20\":1}}],[\"任一节点可在任一时刻主动发送\",{\"1\":{\"20\":1}}],[\"各节点平等\",{\"1\":{\"20\":1}}],[\"多主站结构\",{\"1\":{\"20\":1}}],[\"受干扰概率低\",{\"1\":{\"20\":1}}],[\"传输时间短\",{\"1\":{\"20\":1}}],[\"传输速率最高可达1mbps\",{\"1\":{\"20\":1}}],[\"传输速率为40kbps时\",{\"1\":{\"19\":1}}],[\"传输速率可达1mbps\",{\"1\":{\"19\":1}}],[\"短帧结构\",{\"1\":{\"20\":1}}],[\"组网灵活\",{\"1\":{\"20\":1}}],[\"协议\",{\"2\":{\"33\":1}}],[\"协议本身对节点的数量没有限制\",{\"1\":{\"20\":1}}],[\"协议栈原理\",{\"1\":{\"16\":1}}],[\"光纤\",{\"1\":{\"20\":1}}],[\"双绞线\",{\"1\":{\"20\":1}}],[\"距离最远可达10km\",{\"1\":{\"20\":1}}],[\"属于开环总线\",{\"1\":{\"19\":1}}],[\"属于闭环总线\",{\"1\":{\"19\":1}}],[\"的偏移量即为type的字节大小\",{\"1\":{\"55\":1}}],[\"的地址为0\",{\"1\":{\"55\":1}}],[\"的位置\",{\"1\":{\"55\":2}}],[\"的空指针时type\",{\"1\":{\"55\":1}}],[\"的空指针\",{\"1\":{\"55\":1}}],[\"的指针\",{\"1\":{\"55\":3}}],[\"的运算顺序可以分解为以下步骤\",{\"1\":{\"55\":1}}],[\"的实现通常依赖于编译器和目标体系结构\",{\"1\":{\"54\":1}}],[\"的区别\",{\"0\":{\"41\":1}}],[\"的低速\",{\"1\":{\"19\":1}}],[\"的高速\",{\"1\":{\"19\":1}}],[\"如通信协议\",{\"1\":{\"39\":1}}],[\"如电驱控制\",{\"1\":{\"37\":1}}],[\"如自动驾驶\",{\"1\":{\"36\":1}}],[\"如下图\",{\"1\":{\"19\":2,\"22\":1}}],[\"如发动机的定时\",{\"1\":{\"18\":1}}],[\"≤\",{\"1\":{\"19\":1}}],[\"通过将test\",{\"1\":{\"55\":1}}],[\"通过调用myclass\",{\"1\":{\"51\":1}}],[\"通过can\",{\"1\":{\"21\":1}}],[\"通过执行代理查看指令\",{\"1\":{\"13\":1}}],[\"通信\",{\"1\":{\"37\":1}}],[\"通信介质选择灵活\",{\"1\":{\"20\":1}}],[\"通信标准\",{\"1\":{\"19\":2}}],[\"~1mbps\",{\"1\":{\"19\":1}}],[\"kbps\",{\"1\":{\"19\":2}}],[\"和隐性电平\",{\"1\":{\"21\":1}}],[\"和\",{\"1\":{\"19\":1}}],[\"有计划的动态性\",{\"1\":{\"36\":1}}],[\"有两种\",{\"1\":{\"22\":1}}],[\"有\",{\"1\":{\"19\":1}}],[\"国际标准化的串行通信协议\",{\"1\":{\"19\":1}}],[\"国外已有许多大公司的产品采用了这一技术\",{\"1\":{\"18\":1}}],[\"之间传输数据的线\",{\"1\":{\"19\":1}}],[\"电子控制单元\",{\"1\":{\"19\":1}}],[\"采用面向服务的架构\",{\"1\":{\"36\":1}}],[\"采用双线差分信号\",{\"1\":{\"20\":1}}],[\"采用can总线上述问题便得到很好地解决\",{\"1\":{\"18\":1}}],[\"采用硬接信号线的方式不但烦琐\",{\"1\":{\"18\":1}}],[\"昂贵\",{\"1\":{\"18\":1}}],[\"由于数组索引是从零开始的\",{\"1\":{\"54\":1}}],[\"由于\",{\"1\":{\"54\":1}}],[\"由于这些控制需检测及交换大量数据\",{\"1\":{\"18\":1}}],[\"由于其高性能\",{\"1\":{\"18\":1}}],[\"等\",{\"1\":{\"18\":1}}],[\"及复杂的抗锁定刹车系统\",{\"1\":{\"18\":1}}],[\"及独\",{\"1\":{\"18\":1}}],[\"刹车控制\",{\"1\":{\"18\":1}}],[\"加速\",{\"1\":{\"18\":1}}],[\"注油控制\",{\"1\":{\"18\":1}}],[\"现代汽车越来越多地采用电子装置控制\",{\"1\":{\"18\":1}}],[\"特的设计\",{\"1\":{\"18\":1}}],[\"即控制器局域网络\",{\"1\":{\"18\":1}}],[\"集成及相关调试策略\",{\"1\":{\"16\":1}}],[\"问题解决\",{\"1\":{\"13\":1}}],[\"遇到报错\",{\"1\":{\"13\":1}}],[\"and\",{\"1\":{\"41\":1,\"51\":1}}],[\"all\",{\"1\":{\"41\":1}}],[\"alt\",{\"1\":{\"13\":2,\"40\":1,\"44\":1}}],[\"ap演示代码在次年春季发布\",{\"1\":{\"44\":1}}],[\"ap不会替代ap\",{\"1\":{\"42\":1}}],[\"ap与cp相辅相成\",{\"1\":{\"42\":1}}],[\"application\",{\"1\":{\"41\":1}}],[\"applications\",{\"1\":{\"41\":1}}],[\"app\",{\"1\":{\"41\":1}}],[\"ap分层软件架构特点\",{\"1\":{\"36\":1}}],[\"ap\",{\"0\":{\"36\":1,\"40\":1,\"41\":1},\"1\":{\"41\":1}}],[\"adaptive\",{\"0\":{\"36\":1},\"1\":{\"36\":1}}],[\"address\",{\"1\":{\"41\":2}}],[\"add\",{\"1\":{\"5\":1}}],[\"abs\",{\"1\":{\"18\":1}}],[\"asc\",{\"1\":{\"18\":1}}],[\"area\",{\"1\":{\"18\":1}}],[\"autosar年度关键节点\",{\"0\":{\"44\":1}}],[\"autosar标准制定方式\",{\"0\":{\"43\":1}}],[\"autosar技术标准针对不同的需求提供了不同的解决方案\",{\"1\":{\"35\":1}}],[\"autosar技术标准框架\",{\"0\":{\"35\":1}}],[\"autosar解决方案概述\",{\"0\":{\"34\":1}}],[\"autosar中国官方培训课程\",{\"1\":{\"31\":1,\"45\":1}}],[\"autosar\",{\"0\":{\"16\":1,\"23\":1,\"29\":1,\"30\":1,\"60\":1},\"1\":{\"31\":1,\"45\":1},\"2\":{\"32\":1,\"46\":1}}],[\"案例\",{\"0\":{\"13\":1,\"51\":1}}],[\">\",{\"1\":{\"12\":2}}],[\"优先级通过报文的标识符\",{\"1\":{\"20\":1}}],[\"优先级\",{\"1\":{\"12\":1}}],[\"生效优先级\",{\"0\":{\"12\":1}}],[\"替换为你本地代理的端口\",{\"1\":{\"11\":1}}],[\"unset\",{\"1\":{\"11\":2}}],[\"0和复杂驱动等各个基础软件技术栈\",{\"1\":{\"37\":1}}],[\"0\",{\"1\":{\"10\":4,\"51\":1,\"54\":3,\"55\":10}}],[\"programming\",{\"0\":{\"62\":1}}],[\"proxy\",{\"1\":{\"10\":2,\"11\":2,\"13\":2}}],[\"printf\",{\"1\":{\"51\":1}}],[\"printdata\",{\"1\":{\"51\":7}}],[\"persistent\",{\"1\":{\"41\":1}}],[\"posix\",{\"1\":{\"41\":1}}],[\"port\",{\"1\":{\"10\":2,\"11\":1}}],[\"platform是autosar为开发硬实时\",{\"1\":{\"37\":1}}],[\"platform是autosar为开发安全相关的高算力ecu\",{\"1\":{\"36\":1}}],[\"platform\",{\"0\":{\"36\":1,\"37\":1}}],[\"push\",{\"1\":{\"5\":1}}],[\"设置代理\",{\"0\":{\"10\":1}}],[\"geeksforgeeks\",{\"1\":{\"51\":1}}],[\"general\",{\"1\":{\"28\":1}}],[\"get\",{\"1\":{\"13\":2}}],[\"globalvariable\",{\"1\":{\"50\":1}}],[\"global级是用户级别的配置\",{\"1\":{\"12\":1}}],[\"global\",{\"1\":{\"8\":1,\"10\":2,\"11\":3,\"12\":1,\"13\":2}}],[\"git目录中\",{\"1\":{\"12\":1}}],[\"github代理配置指南\",{\"0\":{\"8\":1}}],[\"github\",{\"0\":{\"59\":1},\"1\":{\"5\":1},\"2\":{\"15\":1}}],[\"git\",{\"1\":{\"5\":5,\"10\":2,\"11\":2,\"13\":2}}],[\"本文主要介绍c语言中sizeof的原理分析\",{\"1\":{\"54\":1}}],[\"本文主要介绍c语言中extern的作用分析\",{\"1\":{\"48\":1}}],[\"本文主要介绍github\",{\"1\":{\"8\":1}}],[\"本文主要讲解autosar解决方案相关内容\",{\"1\":{\"34\":1}}],[\"本文主要讲解autosar\",{\"1\":{\"16\":1}}],[\"本地运行指令可参考下面这个链接\",{\"1\":{\"3\":1}}],[\"使用上一步得到的空指针进行数组操作\",{\"1\":{\"55\":1}}],[\"使用extern关键字可以实现一定程度的面向对象编程\",{\"1\":{\"51\":1}}],[\"使用extern模拟面向对象编程\",{\"0\":{\"51\":1}}],[\"使用指南\",{\"2\":{\"6\":1,\"7\":1,\"14\":1,\"15\":1}}],[\"使用vuepress搭建博客并部署到gitpages上\",{\"0\":{\"3\":1}}],[\"欢迎评论\",{\"1\":{\"5\":1,\"13\":1,\"31\":1,\"45\":1,\"51\":1,\"55\":1}}],[\"欢迎送个表情包或评论\",{\"1\":{\"5\":1,\"13\":1,\"31\":1,\"45\":1,\"51\":1,\"55\":1}}],[\"若有不对之处或建议\",{\"1\":{\"5\":1,\"13\":1,\"31\":1,\"45\":1,\"51\":1,\"55\":1}}],[\"若本文对您有用\",{\"1\":{\"5\":1,\"13\":1,\"31\":1,\"45\":1,\"51\":1,\"55\":1}}],[\"若参考上面项目构建链接\",{\"1\":{\"5\":1}}],[\"提示\",{\"1\":{\"5\":1,\"11\":1,\"12\":1,\"13\":1,\"31\":1,\"45\":1,\"49\":1,\"51\":1,\"55\":1}}],[\"提交本地分支到远程分支\",{\"1\":{\"5\":1}}],[\"<stdio\",{\"1\":{\"51\":1}}],[\"<remote\",{\"1\":{\"5\":1}}],[\"<local\",{\"1\":{\"5\":1}}],[\"3\",{\"1\":{\"5\":1}}],[\"movq\",{\"1\":{\"55\":1}}],[\"main\",{\"1\":{\"51\":2,\"54\":1}}],[\"master\",{\"1\":{\"5\":1}}],[\"myobject\",{\"1\":{\"51\":7}}],[\"myclass\",{\"1\":{\"51\":16}}],[\"myrepo\",{\"1\":{\"5\":1}}],[\"multiple\",{\"1\":{\"41\":1}}],[\"mmu\",{\"1\":{\"41\":1}}],[\"mpu\",{\"1\":{\"41\":1}}],[\"memory\",{\"1\":{\"41\":1}}],[\"mcal配置\",{\"0\":{\"28\":1}}],[\"mcal相关配置\",{\"0\":{\"25\":1}}],[\"mcu的can信号与can总线建立起数据交互\",{\"1\":{\"26\":1}}],[\"mcu的can外设控制模块\",{\"1\":{\"24\":1}}],[\"yourusername\",{\"1\":{\"5\":1}}],[\"c文件编译成汇编文件可发现\",{\"1\":{\"55\":1}}],[\"c文件\",{\"1\":{\"54\":1}}],[\"c语言sizeof宏分析\",{\"0\":{\"54\":1}}],[\"c语言\",{\"2\":{\"53\":1,\"57\":1}}],[\"c语言extern关键字作用分析\",{\"0\":{\"48\":1}}],[\"c中定义的myobject对象\",{\"1\":{\"51\":1}}],[\"c中引用了在myclass\",{\"1\":{\"51\":1}}],[\"c\",{\"0\":{\"61\":1},\"1\":{\"51\":4,\"54\":2}}],[\"cplusplus\",{\"0\":{\"61\":1}}],[\"cp和ap标准\",{\"1\":{\"44\":1}}],[\"cp应用范围更广\",{\"1\":{\"42\":1}}],[\"cp所定义的系统服务\",{\"1\":{\"37\":1}}],[\"cp分层软件架构支持\",{\"1\":{\"37\":1}}],[\"cp\",{\"0\":{\"37\":1,\"40\":1,\"41\":1},\"1\":{\"41\":1}}],[\"classic\",{\"0\":{\"37\":1},\"1\":{\"37\":1}}],[\"can调试策略\",{\"0\":{\"30\":1}}],[\"cantrcv的模式转换主要通过控制dio或者spi来控制硬件trcv\",{\"1\":{\"27\":1}}],[\"cantrcv\",{\"0\":{\"26\":1,\"27\":1}}],[\"canharadwareobject\",{\"1\":{\"25\":1}}],[\"cancontroller\",{\"1\":{\"25\":1}}],[\"cangeneral\",{\"1\":{\"25\":1}}],[\"can模块的收发\",{\"1\":{\"24\":1}}],[\"can系统构成\",{\"0\":{\"22\":1}}],[\"can功能特性\",{\"0\":{\"21\":1}}],[\"can特性\",{\"0\":{\"20\":1}}],[\"can总线上\",{\"1\":{\"21\":1}}],[\"can总线协议是一种iso\",{\"1\":{\"19\":1}}],[\"can总线是一种用于在不同的ecu\",{\"1\":{\"19\":1}}],[\"can标准及原理图\",{\"0\":{\"19\":1}}],[\"can最初是由德国的bosch公司为汽车监测\",{\"1\":{\"18\":1}}],[\"can越来越受到人们的重视\",{\"1\":{\"18\":1}}],[\"can通信概述\",{\"0\":{\"18\":1}}],[\"can通信基本原理\",{\"0\":{\"17\":1}}],[\"can\",{\"0\":{\"24\":1},\"1\":{\"16\":1,\"18\":1,\"19\":2,\"26\":2,\"41\":1},\"2\":{\"33\":1}}],[\"can协议栈集成\",{\"0\":{\"29\":1}}],[\"can协议栈概述\",{\"0\":{\"23\":1}}],[\"can协议栈\",{\"0\":{\"16\":1}}],[\"code\",{\"1\":{\"41\":2}}],[\"controller\",{\"1\":{\"18\":1}}],[\"configuration\",{\"1\":{\"41\":1}}],[\"configset\",{\"1\":{\"28\":1}}],[\"config\",{\"1\":{\"10\":2,\"11\":2,\"13\":2}}],[\"communication\",{\"1\":{\"41\":2}}],[\"com\",{\"1\":{\"5\":1}}],[\"checkout\",{\"1\":{\"5\":1}}],[\"h>\",{\"1\":{\"51\":1}}],[\"h\",{\"1\":{\"51\":6}}],[\"has\",{\"1\":{\"41\":1}}],[\"haedwareabs\",{\"1\":{\"23\":1}}],[\"h和can\",{\"1\":{\"21\":1}}],[\"http\",{\"1\":{\"10\":2,\"11\":1,\"13\":1}}],[\"https\",{\"1\":{\"5\":1,\"10\":2,\"11\":1,\"13\":1}}],[\"hope主题\",{\"1\":{\"3\":1}}],[\"添加远程仓库的引用\",{\"1\":{\"5\":1}}],[\"连接远程分支\",{\"1\":{\"5\":1}}],[\"2023\",{\"1\":{\"51\":2}}],[\"2\",{\"1\":{\"5\":1}}],[\"blog\",{\"0\":{\"58\":1}}],[\"between\",{\"1\":{\"51\":1}}],[\"body\",{\"1\":{\"49\":1}}],[\"based\",{\"1\":{\"41\":3}}],[\"b\",{\"1\":{\"5\":1}}],[\"branch>\",{\"1\":{\"5\":2}}],[\"branch\",{\"1\":{\"5\":1}}],[\"查看本地分支\",{\"1\":{\"5\":1}}],[\"创建本地分支\",{\"1\":{\"5\":2}}],[\"10～125\",{\"1\":{\"19\":1}}],[\"1080\",{\"1\":{\"10\":1}}],[\"125\",{\"1\":{\"19\":1}}],[\"127\",{\"1\":{\"10\":2}}],[\"11519两个系列\",{\"1\":{\"19\":1}}],[\"11898\",{\"1\":{\"19\":2}}],[\"1\",{\"1\":{\"5\":1,\"10\":2,\"54\":2,\"55\":6}}],[\"此时本地git仓库已初始化\",{\"1\":{\"5\":1}}],[\"部署到gitpages\",{\"0\":{\"5\":1}}],[\"小白教程\",{\"1\":{\"4\":1}}],[\"参考链接\",{\"0\":{\"31\":1,\"45\":1},\"1\":{\"4\":1,\"51\":1}}],[\"项目构建\",{\"0\":{\"4\":1}}],[\"项目环境\",{\"1\":{\"3\":1}}],[\"构建\",{\"1\":{\"3\":1}}],[\"幻灯片页\",{\"0\":{\"2\":1}}],[\"介绍页\",{\"0\":{\"1\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
